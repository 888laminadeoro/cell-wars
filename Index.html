<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Agar.io Clone - Juego Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a0e27;
            color: #fff;
            touch-action: none;
        }

        .menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d3a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-container {
            text-align: center;
            padding: 20px;
            max-width: 600px;
            width: 90%;
        }

        .menu-container h1 {
            font-size: 3rem;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        .skin-selector h2 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #a0a0a0;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .skin-item {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            padding: 10px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
        }

        .skin-item:hover {
            transform: translateY(-5px);
        }

        .skin-item.selected {
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            transform: scale(1.05);
        }

        .skin-preview {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .skin-item span {
            display: block;
            font-size: 0.9rem;
            color: #ccc;
        }

        .start-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 60px;
            font-size: 1.3rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            font-weight: bold;
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        .start-btn:active {
            transform: translateY(0);
        }

        .game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 14, 39, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .hud-item:last-child {
            margin-bottom: 0;
        }

        .hud-label {
            color: #888;
            margin-right: 15px;
        }

        #massDisplay,
        #fpsDisplay,
        #skinDisplay {
            color: #fff;
            font-weight: bold;
        }

        .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(10, 14, 39, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 100;
        }

        .fullscreen-btn:hover {
            background: rgba(102, 126, 234, 0.5);
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            .menu-container h1 {
                font-size: 2rem;
            }

            .skins-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }

            .skin-preview {
                width: 60px;
                height: 60px;
            }

            .start-btn {
                padding: 12px 40px;
                font-size: 1.1rem;
            }

            .hud {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div id="menu" class="menu">
        <div class="menu-container">
            <h1>CELL BATTLE</h1>
            <div class="skin-selector">
                <h2>Selecciona tu Skin</h2>
                <div class="skins-grid">
                    <div class="skin-item" data-skin="0">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                        <span>Galaxia</span>
                    </div>
                    <div class="skin-item" data-skin="1">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);"></div>
                        <span>Rosa</span>
                    </div>
                    <div class="skin-item" data-skin="2">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);"></div>
                        <span>Hielo</span>
                    </div>
                    <div class="skin-item" data-skin="3">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);"></div>
                        <span>Esmeralda</span>
                    </div>
                    <div class="skin-item" data-skin="4">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);"></div>
                        <span>Fuego</span>
                    </div>
                    <div class="skin-item" data-skin="5">
                        <div class="skin-preview" style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);"></div>
                        <span>Océano</span>
                    </div>
                </div>
            </div>
            <button id="startBtn" class="start-btn">INICIAR JUEGO</button>
        </div>
    </div>

    <div id="gameContainer" class="game-container" style="display: none;">
        <canvas id="gameCanvas"></canvas>
        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">Masa:</span>
                <span id="massDisplay">100</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">FPS:</span>
                <span id="fpsDisplay">60</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Skin:</span>
                <span id="skinDisplay">Galaxia</span>
            </div>
        </div>
        <button id="fullscreenBtn" class="fullscreen-btn">⛶</button>
    </div>

    <script>
        const CONFIG = {
            MAP_SIZE: 5000,
            INITIAL_PELLETS: 500,
            PELLET_RADIUS: 5,
            INITIAL_MASS: 100,
            BASE_SPEED: 400,
            ZOOM_CONSTANT: 1000,
            AI_COUNT: 15,
            AI_UPDATE_INTERVAL: 100,
            TARGET_FPS: 60
        };

        const SKINS = [
            {name: 'Galaxia', gradient: ['#667eea', '#764ba2']},
            {name: 'Rosa', gradient: ['#f093fb', '#f5576c']},
            {name: 'Hielo', gradient: ['#4facfe', '#00f2fe']},
            {name: 'Esmeralda', gradient: ['#43e97b', '#38f9d7']},
            {name: 'Fuego', gradient: ['#fa709a', '#fee140']},
            {name: 'Océano', gradient: ['#30cfd0', '#330867']}
        ];

        const ABSORB_SOUND_BASE64 = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                this.player = null;
                this.pellets = [];
                this.enemies = [];
                this.camera = {x: 0, y: 0, zoom: 1};
                this.input = {x: 0, y: 0};
                this.selectedSkin = 0;
                this.gameStarted = false;
                
                this.lastTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                this.absorbSound = new Audio(ABSORB_SOUND_BASE64);
                
                this.setupEventListeners();
                this.generatePellets();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }
            
            setupEventListeners() {
                const menu = document.getElementById('menu');
                const gameContainer = document.getElementById('gameContainer');
                const startBtn = document.getElementById('startBtn');
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                
                document.querySelectorAll('.skin-item').forEach((item, index) => {
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.skin-item').forEach(el => el.classList.remove('selected'));
                        item.classList.add('selected');
                        this.selectedSkin = index;
                    });
                });
                
                document.querySelector('.skin-item').classList.add('selected');
                
                startBtn.addEventListener('click', () => {
                    menu.style.display = 'none';
                    gameContainer.style.display = 'block';
                    this.startGame();
                });
                
                fullscreenBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(() => {});
                    } else {
                        document.exitFullscreen();
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.input.x = e.clientX - rect.left;
                    this.input.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    this.input.x = touch.clientX - rect.left;
                    this.input.y = touch.clientY - rect.top;
                }, {passive: false});
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    this.input.x = touch.clientX - rect.left;
                    this.input.y = touch.clientY - rect.top;
                }, {passive: false});
            }
            
            startGame() {
                this.player = {
                    x: CONFIG.MAP_SIZE / 2,
                    y: CONFIG.MAP_SIZE / 2,
                    mass: CONFIG.INITIAL_MASS,
                    vx: 0,
                    vy: 0,
                    skin: this.selectedSkin
                };
                
                this.generateEnemies();
                this.gameStarted = true;
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
                
                document.getElementById('skinDisplay').textContent = SKINS[this.selectedSkin].name;
            }
            
            generatePellets() {
                this.pellets = [];
                for (let i = 0; i < CONFIG.INITIAL_PELLETS; i++) {
                    this.pellets.push({
                        x: Math.random() * CONFIG.MAP_SIZE,
                        y: Math.random() * CONFIG.MAP_SIZE,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`
                    });
                }
            }
            
            generateEnemies() {
                this.enemies = [];
                for (let i = 0; i < CONFIG.AI_COUNT; i++) {
                    const mass = 50 + Math.random() * 200;
                    this.enemies.push({
                        x: Math.random() * CONFIG.MAP_SIZE,
                        y: Math.random() * CONFIG.MAP_SIZE,
                        mass: mass,
                        vx: 0,
                        vy: 0,
                        targetX: Math.random() * CONFIG.MAP_SIZE,
                        targetY: Math.random() * CONFIG.MAP_SIZE,
                        behavior: 'roaming',
                        lastBehaviorUpdate: 0,
                        skin: Math.floor(Math.random() * SKINS.length)
                    });
                }
            }
            
            getRadius(mass) {
                return Math.sqrt(mass / Math.PI);
            }
            
            getSpeed(mass) {
                return CONFIG.BASE_SPEED / Math.sqrt(mass);
            }
            
            checkCircleCollision(x1, y1, r1, x2, y2, r2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < r1 + r2;
            }
            
            canAbsorb(mass1, mass2) {
                return mass1 > mass2 * 1.1;
            }
            
            updatePlayer(dt) {
                const radius = this.getRadius(this.player.mass);
                const speed = this.getSpeed(this.player.mass);
                
                const screenX = this.input.x;
                const screenY = this.input.y;
                const worldX = (screenX - this.canvas.width / 2) / this.camera.zoom + this.camera.x;
                const worldY = (screenY - this.canvas.height / 2) / this.camera.zoom + this.camera.y;
                
                const dx = worldX - this.player.x;
                const dy = worldY - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    const targetVx = (dx / dist) * speed;
                    const targetVy = (dy / dist) * speed;
                    
                    this.player.vx += (targetVx - this.player.vx) * 0.1;
                    this.player.vy += (targetVy - this.player.vy) * 0.1;
                } else {
                    this.player.vx *= 0.9;
                    this.player.vy *= 0.9;
                }
                
                this.player.x += this.player.vx * dt;
                this.player.y += this.player.vy * dt;
                
                this.player.x = Math.max(radius, Math.min(CONFIG.MAP_SIZE - radius, this.player.x));
                this.player.y = Math.max(radius, Math.min(CONFIG.MAP_SIZE - radius, this.player.y));
                
                for (let i = this.pellets.length - 1; i >= 0; i--) {
                    const pellet = this.pellets[i];
                    if (this.checkCircleCollision(this.player.x, this.player.y, radius, pellet.x, pellet.y, CONFIG.PELLET_RADIUS)) {
                        this.player.mass += Math.PI * CONFIG.PELLET_RADIUS * CONFIG.PELLET_RADIUS;
                        this.pellets.splice(i, 1);
                        this.playAbsorbSound();
                        
                        this.pellets.push({
                            x: Math.random() * CONFIG.MAP_SIZE,
                            y: Math.random() * CONFIG.MAP_SIZE,
                            color: `hsl(${Math.random() * 360}, 70%, 60%)`
                        });
                    }
                }
                
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const enemyRadius = this.getRadius(enemy.mass);
                    
                    if (this.checkCircleCollision(this.player.x, this.player.y, radius, enemy.x, enemy.y, enemyRadius)) {
                        if (this.canAbsorb(this.player.mass, enemy.mass)) {
                            this.player.mass += enemy.mass;
                            this.enemies.splice(i, 1);
                            this.playAbsorbSound();
                            
                            const mass = 50 + Math.random() * 200;
                            this.enemies.push({
                                x: Math.random() * CONFIG.MAP_SIZE,
                                y: Math.random() * CONFIG.MAP_SIZE,
                                mass: mass,
                                vx: 0,
                                vy: 0,
                                targetX: Math.random() * CONFIG.MAP_SIZE,
                                targetY: Math.random() * CONFIG.MAP_SIZE,
                                behavior: 'roaming',
                                lastBehaviorUpdate: 0,
                                skin: Math.floor(Math.random() * SKINS.length)
                            });
                        } else if (this.canAbsorb(enemy.mass, this.player.mass)) {
                            this.gameOver();
                            return;
                        }
                    }
                }
            }
            
            updateEnemies(dt, currentTime) {
                const playerRadius = this.getRadius(this.player.mass);
                
                for (const enemy of this.enemies) {
                    const enemyRadius = this.getRadius(enemy.mass);
                    
                    if (currentTime - enemy.lastBehaviorUpdate > CONFIG.AI_UPDATE_INTERVAL) {
                        enemy.lastBehaviorUpdate = currentTime;
                        
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distToPlayer < 300) {
                            if (this.canAbsorb(enemy.mass, this.player.mass)) {
                                enemy.behavior = 'chase';
                                enemy.targetX = this.player.x;
                                enemy.targetY = this.player.y;
                            } else if (this.canAbsorb(this.player.mass, enemy.mass)) {
                                enemy.behavior = 'flee';
                                enemy.targetX = enemy.x - dx;
                                enemy.targetY = enemy.y - dy;
                            } else {
                                enemy.behavior = 'roaming';
                            }
                        } else {
                            enemy.behavior = 'roaming';
                        }
                        
                        if (enemy.behavior === 'roaming') {
                            const distToTarget = Math.sqrt(
                                (enemy.targetX - enemy.x) ** 2 + (enemy.targetY - enemy.y) ** 2
                            );
                            
                            if (distToTarget < 50 || Math.random() < 0.02) {
                                enemy.targetX = Math.random() * CONFIG.MAP_SIZE;
                                enemy.targetY = Math.random() * CONFIG.MAP_SIZE;
                            }
                        }
                    }
                    
                    const dx = enemy.targetX - enemy.x;
                    const dy = enemy.targetY - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 5) {
                        const speed = this.getSpeed(enemy.mass) * 0.7;
                        const targetVx = (dx / dist) * speed;
                        const targetVy = (dy / dist) * speed;
                        
                        enemy.vx += (targetVx - enemy.vx) * 0.05;
                        enemy.vy += (targetVy - enemy.vy) * 0.05;
                    } else {
                        enemy.vx *= 0.95;
                        enemy.vy *= 0.95;
                    }
                    
                    enemy.x += enemy.vx * dt;
                    enemy.y += enemy.vy * dt;
                    
                    enemy.x = Math.max(enemyRadius, Math.min(CONFIG.MAP_SIZE - enemyRadius, enemy.x));
                    enemy.y = Math.max(enemyRadius, Math.min(CONFIG.MAP_SIZE - enemyRadius, enemy.y));
                    
                    for (let i = this.pellets.length - 1; i >= 0; i--) {
                        const pellet = this.pellets[i];
                        if (this.checkCircleCollision(enemy.x, enemy.y, enemyRadius, pellet.x, pellet.y, CONFIG.PELLET_RADIUS)) {
                            enemy.mass += Math.PI * CONFIG.PELLET_RADIUS * CONFIG.PELLET_RADIUS;
                            this.pellets.splice(i, 1);
                            
                            this.pellets.push({
                                x: Math.random() * CONFIG.MAP_SIZE,
                                y: Math.random() * CONFIG.MAP_SIZE,
                                color: `hsl(${Math.random() * 360}, 70%, 60%)`
                            });
                        }
                    }
                }
                
                for (let i = 0; i < this.enemies.length; i++) {
                    for (let j = i + 1; j < this.enemies.length; j++) {
                        const e1 = this.enemies[i];
                        const e2 = this.enemies[j];
                        const r1 = this.getRadius(e1.mass);
                        const r2 = this.getRadius(e2.mass);
                        
                        if (this.checkCircleCollision(e1.x, e1.y, r1, e2.x, e2.y, r2)) {
                            if (this.canAbsorb(e1.mass, e2.mass)) {
                                e1.mass += e2.mass;
                                this.enemies.splice(j, 1);
                                j--;
                                
                                const mass = 50 + Math.random() * 200;
                                this.enemies.push({
                                    x: Math.random() * CONFIG.MAP_SIZE,
                                    y: Math.random() * CONFIG.MAP_SIZE,
                                    mass: mass,
                                    vx: 0,
                                    vy: 0,
                                    targetX: Math.random() * CONFIG.MAP_SIZE,
                                    targetY: Math.random() * CONFIG.MAP_SIZE,
                                    behavior: 'roaming',
                                    lastBehaviorUpdate: 0,
                                    skin: Math.floor(Math.random() * SKINS.length)
                                });
                            } else if (this.canAbsorb(e2.mass, e1.mass)) {
                                e2.mass += e1.mass;
                                this.enemies.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                    }
                }
            }
            
            updateCamera() {
                this.camera.zoom = CONFIG.ZOOM_CONSTANT / Math.sqrt(this.player.mass);
                this.camera.zoom = Math.max(0.3, Math.min(2, this.camera.zoom));
                
                const targetX = this.player.x;
                const targetY = this.player.y;
                
                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;
            }
            
            drawGrid() {
                const ctx = this.ctx;
                const gridSize = 50;
                
                const startX = Math.floor((this.camera.x - this.canvas.width / 2 / this.camera.zoom) / gridSize) * gridSize;
                const startY = Math.floor((this.camera.y - this.canvas.height / 2 / this.camera.zoom) / gridSize) * gridSize;
                const endX = this.camera.x + this.canvas.width / 2 / this.camera.zoom;
                const endY = this.camera.y + this.canvas.height / 2 / this.camera.zoom;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1 / this.camera.zoom;
                
                ctx.beginPath();
                for (let x = startX; x < endX; x += gridSize) {
                    const screenX = (x - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, this.canvas.height);
                }
                for (let y = startY; y < endY; y += gridSize) {
                    const screenY = (y - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(this.canvas.width, screenY);
                }
                ctx.stroke();
            }
            
            drawCell(x, y, radius, skinIndex) {
                const ctx = this.ctx;
                const screenX = (x - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
                const screenY = (y - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
                const screenRadius = radius * this.camera.zoom;
                
                const skin = SKINS[skinIndex];
                const gradient = ctx.createLinearGradient(
                    screenX - screenRadius, screenY - screenRadius,
                    screenX + screenRadius, screenY + screenRadius
                );
                gradient.addColorStop(0, skin.gradient[0]);
                gradient.addColorStop(1, skin.gradient[1]);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = `${Math.max(12, screenRadius * 0.4)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.floor(x === this.player.x ? this.player.mass : y), screenX, screenY);
            }
            
            render() {
                const ctx = this.ctx;
                
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.save();
                
                this.drawGrid();
                
                for (const pellet of this.pellets) {
                    const screenX = (pellet.x - this.camera.x) * this.camera.zoom + this.canvas.width / 2;
                    const screenY = (pellet.y - this.camera.y) * this.camera.zoom + this.canvas.height / 2;
                    const screenRadius = CONFIG.PELLET_RADIUS * this.camera.zoom;
                    
                    if (screenX > -50 && screenX < this.canvas.width + 50 &&
                        screenY > -50 && screenY < this.canvas.height + 50) {
                        ctx.fillStyle = pellet.color;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                const allCells = [...this.enemies, this.player].sort((a, b) => {
                    const massA = a.mass || 0;
                    const massB = b.mass || 0;
                    return massA - massB;
                });
                
                for (const cell of allCells) {
                    const radius = this.getRadius(cell.mass);
                    this.drawCell(cell.x, cell.y, radius, cell.skin);
                }
                
                ctx.restore();
                
                document.getElementById('massDisplay').textContent = Math.floor(this.player.mass);
            }
            
            gameLoop(currentTime) {
                if (!this.gameStarted) return;
                
                const dt = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;
                
                this.updatePlayer(dt);
                this.updateEnemies(dt, currentTime);
                this.updateCamera();
                this.render();
                
                this.frameCount++;
                if (currentTime - this.lastFpsUpdate > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    document.getElementById('fpsDisplay').textContent = this.fps;
                }
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            playAbsorbSound() {
                try {
                    this.absorbSound.currentTime = 0;
                    this.absorbSound.play().catch(() => {});
                } catch (e) {}
            }
            
            gameOver() {
                this.gameStarted = false;
                alert('¡Game Over! Tu masa final: ' + Math.floor(this.player.mass));
                location.reload();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new Game();
        });
    </script>
</body>
</html>
